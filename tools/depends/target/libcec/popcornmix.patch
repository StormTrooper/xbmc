From 651fc15222923bcaea6f7925c207217a40e967ab Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Fri, 24 Oct 2014 13:45:21 +0100
Subject: [PATCH 1/5] Make released key polling wait for exact time until key
 gets released

---
 src/lib/CECClient.cpp    | 28 ++++++++++++++++++++++++----
 src/lib/CECClient.h      |  2 +-
 src/lib/CECProcessor.cpp |  8 +++++---
 src/lib/LibCEC.cpp       | 10 ++++++++--
 src/lib/LibCEC.h         |  4 +++-
 5 files changed, 41 insertions(+), 11 deletions(-)

diff --git a/src/lib/CECClient.cpp b/src/lib/CECClient.cpp
index 0bc9705..5fb1e6a 100644
--- a/src/lib/CECClient.cpp
+++ b/src/lib/CECClient.cpp
@@ -1057,10 +1057,16 @@ void CCECClient::SetCurrentButton(const cec_user_control_code iButtonCode)
   AddKey(key);
 }

-void CCECClient::CheckKeypressTimeout(void)
+uint16_t CCECClient::CheckKeypressTimeout(void)
 {
+  // time when we'd like to be called again
+  unsigned int timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
   cec_keypress key;
+  key.keycode = CEC_USER_CONTROL_CODE_UNKNOWN;
+  key.duration = 0;

+  if (m_iCurrentButton == CEC_USER_CONTROL_CODE_UNKNOWN)
+    return timeout;
   {
     CLockObject lock(m_mutex);
     uint64_t iNow = GetTimeMs();
@@ -1081,12 +1087,26 @@ void CCECClient::CheckKeypressTimeout(void)
     }
     else
     {
-      return;
+      // time when this keypress will be released and we'd like to be called again
+      unsigned int timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
+      if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN && m_iCurrentButton == comboKey && iTimeoutMs > 0)
+        timeout = iTimeoutMs - (iNow - m_buttontime) + 1;
+      else if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN && m_iCurrentButton != comboKey)
+        timeout = CEC_BUTTON_TIMEOUT - (iNow - m_buttontime) + 1;
+      if (timeout > CEC_PROCESSOR_SIGNAL_WAIT_TIME)
+      {
+        LIB_CEC->AddLog(CEC_LOG_ERROR, "Unexpected timeout: %d (%.3f %.3f %.3f) k:%02x", timeout, iNow*1e-3, m_buttontime*1e-3, CEC_BUTTON_TIMEOUT*1e-3, m_iCurrentButton);
+        timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
+      }
     }
   }

-  LIB_CEC->AddLog(CEC_LOG_DEBUG, "key auto-released: %s (%1x)", ToString(key.keycode), key.keycode);
-  CallbackAddKey(key);
+  if (key.keycode != CEC_USER_CONTROL_CODE_UNKNOWN)
+  {
+    LIB_CEC->AddLog(CEC_LOG_DEBUG, "key auto-released: %s (%1x)", ToString(key.keycode), key.keycode);
+    CallbackAddKey(key);
+  }
+  return timeout;
 }

 bool CCECClient::EnableCallbacks(void *cbParam, ICECCallbacks *callbacks)
diff --git a/src/lib/CECClient.h b/src/lib/CECClient.h
index 3ef0453..88efbbb 100644
--- a/src/lib/CECClient.h
+++ b/src/lib/CECClient.h
@@ -182,7 +182,7 @@ namespace CEC
     virtual void                  AddKey(bool bSendComboKey = false);
     virtual void                  AddKey(const cec_keypress &key);
     virtual void                  SetCurrentButton(const cec_user_control_code iButtonCode);
-    virtual void                  CheckKeypressTimeout(void);
+    virtual uint16_t              CheckKeypressTimeout(void);
     virtual void                  SourceActivated(const cec_logical_address logicalAddress);
     virtual void                  SourceDeactivated(const cec_logical_address logicalAddress);

diff --git a/src/lib/CECProcessor.cpp b/src/lib/CECProcessor.cpp
index 557b76d..ecf9244 100644
--- a/src/lib/CECProcessor.cpp
+++ b/src/lib/CECProcessor.cpp
@@ -51,7 +51,6 @@ using namespace CEC;
 using namespace std;
 using namespace PLATFORM;

-#define CEC_PROCESSOR_SIGNAL_WAIT_TIME 1000
 #define ACTIVE_SOURCE_CHECK_INTERVAL   500
 #define TV_PRESENT_CHECK_INTERVAL      30000

@@ -244,6 +243,7 @@ bool CCECProcessor::OnCommandReceived(const cec_command &command)

 void *CCECProcessor::Process(void)
 {
+  uint16_t timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
   m_libcec->AddLog(CEC_LOG_DEBUG, "processor thread started");

   if (!m_connCheck)
@@ -258,13 +258,13 @@ void *CCECProcessor::Process(void)
   while (!IsStopped() && m_communication->IsOpen())
   {
     // wait for a new incoming command, and process it
-    if (m_inBuffer.Pop(command, CEC_PROCESSOR_SIGNAL_WAIT_TIME))
+    if (m_inBuffer.Pop(command, timeout))
       ProcessCommand(command);

     if (CECInitialised() && !IsStopped())
     {
       // check clients for keypress timeouts
-      m_libcec->CheckKeypressTimeout();
+      timeout = m_libcec->CheckKeypressTimeout();

       // check if we need to replace handlers
       ReplaceHandlers();
@@ -295,6 +295,8 @@ void *CCECProcessor::Process(void)
         tvPresentCheck.Init(TV_PRESENT_CHECK_INTERVAL);
       }
     }
+    else
+      timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
   }

   return NULL;
diff --git a/src/lib/LibCEC.cpp b/src/lib/LibCEC.cpp
index c24b4ed..046205c 100644
--- a/src/lib/LibCEC.cpp
+++ b/src/lib/LibCEC.cpp
@@ -354,11 +354,17 @@ bool CLibCEC::IsValidPhysicalAddress(uint16_t iPhysicalAddress)
          iPhysicalAddress <= CEC_MAX_PHYSICAL_ADDRESS;
 }

-void CLibCEC::CheckKeypressTimeout(void)
+uint16_t CLibCEC::CheckKeypressTimeout(void)
 {
+  uint16_t timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
   // check all clients
   for (vector<CCECClient *>::iterator it = m_clients.begin(); it != m_clients.end(); it++)
-    (*it)->CheckKeypressTimeout();
+  {
+    uint16_t t = (*it)->CheckKeypressTimeout();
+    if (t < timeout)
+      timeout = t;
+  }
+  return timeout;
 }

 void CLibCEC::AddLog(const cec_log_level level, const char *strFormat, ...)
diff --git a/src/lib/LibCEC.h b/src/lib/LibCEC.h
index 3a312c0..b7ac645 100644
--- a/src/lib/LibCEC.h
+++ b/src/lib/LibCEC.h
@@ -36,6 +36,8 @@
 #include "platform/util/buffer.h"
 #include "CECTypeUtils.h"

+#define CEC_PROCESSOR_SIGNAL_WAIT_TIME 1000
+
 namespace CEC
 {
   class CAdapterCommunication;
@@ -121,7 +123,7 @@ namespace CEC

       void AddLog(const cec_log_level level, const char *strFormat, ...);
       void AddCommand(const cec_command &command);
-      void CheckKeypressTimeout(void);
+      uint16_t CheckKeypressTimeout(void);
       void Alert(const libcec_alert type, const libcec_parameter &param);

       static bool IsValidPhysicalAddress(uint16_t iPhysicalAddress);
--
1.9.1


From d506af4cff04156391f34d07f921e02c41a563b7 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 24 Nov 2014 23:18:52 +0000
Subject: [PATCH 2/5] Add settings for repeat and release

---
 include/cectypes.h    | 6 ++++++
 src/lib/CECClient.cpp | 6 ++++++
 2 files changed, 12 insertions(+)

diff --git a/include/cectypes.h b/include/cectypes.h
index 0a90d0e..b75b1b3 100644
--- a/include/cectypes.h
+++ b/include/cectypes.h
@@ -1532,6 +1532,8 @@ struct libcec_configuration
                                                    XXX changed meaning in 2.2.0 to not break binary compatibility. next major (3.0) release will fix it in a nicer way */
   cec_user_control_code comboKey;             /*!< key code that initiates combo keys. defaults to CEC_USER_CONTROL_CODE_F1_BLUE. CEC_USER_CONTROL_CODE_UNKNOWN to disable. added in 2.0.5 */
   uint32_t              iComboKeyTimeoutMs;   /*!< timeout until the combo key is sent as normal keypress */
+  uint32_t              iButtonRepeatRateMs;  /*!< rate at which buttons autorepeat. 0 means rely on CEC device */
+  uint32_t              iButtonReleaseDelayMs;/*!< duration after last update until a button is considered released */

 #ifdef __cplusplus
    libcec_configuration(void) { Clear(); }
@@ -1566,6 +1568,8 @@ struct libcec_configuration
                  cecVersion                == other.cecVersion &&
                  adapterType               == other.adapterType &&
                  iDoubleTapTimeout50Ms     == other.iDoubleTapTimeout50Ms &&
+                 iButtonRepeatRateMs       == other.iButtonRepeatRateMs &&
+                 iButtonReleaseDelayMs     == other.iButtonReleaseDelayMs &&
                  (other.clientVersion <= CEC_CLIENT_VERSION_2_0_4 || comboKey            == other.comboKey) &&
                  (other.clientVersion <= CEC_CLIENT_VERSION_2_0_4 || iComboKeyTimeoutMs  == other.iComboKeyTimeoutMs) &&
                  (other.clientVersion <  CEC_CLIENT_VERSION_2_1_0 || bPowerOnScreensaver == other.bPowerOnScreensaver));
@@ -1606,6 +1610,8 @@ struct libcec_configuration
     iDoubleTapTimeout50Ms =           CEC_DOUBLE_TAP_TIMEOUT_50_MS;
     comboKey =                        CEC_USER_CONTROL_CODE_STOP;
     iComboKeyTimeoutMs =              CEC_DEFAULT_COMBO_TIMEOUT_MS;
+    iButtonRepeatRateMs =             0;
+    iButtonReleaseDelayMs =           CEC_BUTTON_TIMEOUT;

     memset(strDeviceName, 0, 13);
     deviceTypes.Clear();
diff --git a/src/lib/CECClient.cpp b/src/lib/CECClient.cpp
index 5fb1e6a..02f5f4a 100644
--- a/src/lib/CECClient.cpp
+++ b/src/lib/CECClient.cpp
@@ -834,6 +834,9 @@ bool CCECClient::GetCurrentConfiguration(libcec_configuration &configuration)
   configuration.bMonitorOnly              = m_configuration.bMonitorOnly;
   configuration.cecVersion                = m_configuration.cecVersion;
   configuration.adapterType               = m_configuration.adapterType;
+  configuration.iDoubleTapTimeout50Ms     = m_configuration.iDoubleTapTimeout50Ms;
+  configuration.iButtonRepeatRateMs       = m_configuration.iButtonRepeatRateMs;
+  configuration.iButtonReleaseDelayMs     = m_configuration.iButtonReleaseDelayMs;

   return true;
 }
@@ -877,6 +880,9 @@ bool CCECClient::SetConfiguration(const libcec_configuration &configuration)
     m_configuration.cecVersion                 = configuration.cecVersion;
     m_configuration.adapterType                = configuration.adapterType;
     m_configuration.iDoubleTapTimeout50Ms      = configuration.iDoubleTapTimeout50Ms;
+    m_configuration.iButtonRepeatRateMs        = configuration.iButtonRepeatRateMs;
+    m_configuration.iButtonReleaseDelayMs      = configuration.iButtonReleaseDelayMs;
+
     m_configuration.deviceTypes.Add(configuration.deviceTypes[0]);

     if (m_configuration.clientVersion >= CEC_CLIENT_VERSION_2_0_5)
--
1.9.1


From b6a6cc8ad12571dff0e02bc9a38ce97a00424df0 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 24 Nov 2014 23:20:05 +0000
Subject: [PATCH 3/5] Distinguish explicit and implicit forms of AddKey
 releases

---
 src/lib/CECClient.cpp                         | 2 +-
 src/lib/CECClient.h                           | 2 +-
 src/lib/implementations/CECCommandHandler.cpp | 2 +-
 3 files changed, 3 insertions(+), 3 deletions(-)

diff --git a/src/lib/CECClient.cpp b/src/lib/CECClient.cpp
index 02f5f4a..3663b24 100644
--- a/src/lib/CECClient.cpp
+++ b/src/lib/CECClient.cpp
@@ -968,7 +968,7 @@ int CCECClient::MenuStateChanged(const cec_menu_state newState)
   return CallbackMenuStateChanged(newState);
 }

-void CCECClient::AddKey(bool bSendComboKey /* = false */)
+void CCECClient::AddKey(bool bSendComboKey /* = false */, bool bButtonRelease /* = false */)
 {
   cec_keypress key;
   key.keycode = CEC_USER_CONTROL_CODE_UNKNOWN;
diff --git a/src/lib/CECClient.h b/src/lib/CECClient.h
index 88efbbb..84fb909 100644
--- a/src/lib/CECClient.h
+++ b/src/lib/CECClient.h
@@ -179,7 +179,7 @@ namespace CEC
     virtual int                   MenuStateChanged(const cec_menu_state newState);
     virtual void                  Alert(const libcec_alert type, const libcec_parameter &param) { CallbackAlert(type, param); }
     virtual void                  AddLog(const cec_log_message &message) { CallbackAddLog(message); }
-    virtual void                  AddKey(bool bSendComboKey = false);
+    virtual void                  AddKey(bool bSendComboKey = false, bool bButtonRelease = false);
     virtual void                  AddKey(const cec_keypress &key);
     virtual void                  SetCurrentButton(const cec_user_control_code iButtonCode);
     virtual uint16_t              CheckKeypressTimeout(void);
diff --git a/src/lib/implementations/CECCommandHandler.cpp b/src/lib/implementations/CECCommandHandler.cpp
index a89ebe6..932c54b 100644
--- a/src/lib/implementations/CECCommandHandler.cpp
+++ b/src/lib/implementations/CECCommandHandler.cpp
@@ -745,7 +745,7 @@ int CCECCommandHandler::HandleUserControlRelease(const cec_command &command)

   CCECClient *client = m_processor->GetClient(command.destination);
   if (client)
-    client->AddKey();
+    client->AddKey(false, true);

   return COMMAND_HANDLED;
 }
--
1.9.1


From 3b7606a9e0653149ae4b6e80d0df9c53645bfac9 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Mon, 24 Nov 2014 23:20:22 +0000
Subject: [PATCH 4/5] Support repeating button presses with configurable repeat
 rate Keep track of time since initial button press and last button update

---
 src/lib/CECClient.cpp | 119 ++++++++++++++++++++++++++++++++++++++++----------
 src/lib/CECClient.h   |   6 ++-
 2 files changed, 101 insertions(+), 24 deletions(-)

diff --git a/src/lib/CECClient.cpp b/src/lib/CECClient.cpp
index 3663b24..68eaee9 100644
--- a/src/lib/CECClient.cpp
+++ b/src/lib/CECClient.cpp
@@ -52,7 +52,11 @@ CCECClient::CCECClient(CCECProcessor *processor, const libcec_configuration &con
     m_bInitialised(false),
     m_bRegistered(false),
     m_iCurrentButton(CEC_USER_CONTROL_CODE_UNKNOWN),
-    m_buttontime(0),
+    m_initialButtontime(0),
+    m_updateButtontime(0),
+    m_repeatButtontime(0),
+    m_releaseButtontime(0),
+    m_pressedButtoncount(0),
     m_iPreventForwardingPowerOffCommand(0),
     m_iLastKeypressTime(0)
 {
@@ -939,6 +943,7 @@ bool CCECClient::SetConfiguration(const libcec_configuration &configuration)
     primary->ActivateSource();
   }

+  LIB_CEC->AddLog(CEC_LOG_DEBUG, "%s: %d:%d:%d", __FUNCTION__, DoubleTapTimeoutMS(), m_configuration.iButtonRepeatRateMs, m_configuration.iButtonReleaseDelayMs);
   return true;
 }

@@ -977,9 +982,10 @@ void CCECClient::AddKey(bool bSendComboKey /* = false */, bool bButtonRelease /*
     CLockObject lock(m_mutex);
     if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN)
     {
-      key.duration = (unsigned int) (GetTimeMs() - m_buttontime);
+      unsigned int duration = (unsigned int) (GetTimeMs() - m_updateButtontime);
+      key.duration = (unsigned int) (GetTimeMs() - m_initialButtontime);

-      if (key.duration > m_configuration.iComboKeyTimeoutMs ||
+      if (duration > m_configuration.iComboKeyTimeoutMs ||
           m_configuration.iComboKeyTimeoutMs == 0 ||
           m_iCurrentButton != m_configuration.comboKey ||
           bSendComboKey)
@@ -987,14 +993,22 @@ void CCECClient::AddKey(bool bSendComboKey /* = false */, bool bButtonRelease /*
         key.keycode = m_iCurrentButton;

         m_iCurrentButton = CEC_USER_CONTROL_CODE_UNKNOWN;
-        m_buttontime = 0;
+        m_initialButtontime = 0;
+        m_updateButtontime = 0;
+        m_repeatButtontime = 0;
+        m_releaseButtontime = 0;
+        m_pressedButtoncount = 0;
       }
     }
   }

+  // we don't forward releases when supporting repeating keys
+  if (bButtonRelease && m_configuration.iButtonRepeatRateMs)
+    return;
+
   if (key.keycode != CEC_USER_CONTROL_CODE_UNKNOWN)
   {
-    LIB_CEC->AddLog(CEC_LOG_DEBUG, "key released: %s (%1x)", ToString(key.keycode), key.keycode);
+    LIB_CEC->AddLog(CEC_LOG_DEBUG, "key released: %s (%1x) D:%dms", ToString(key.keycode), key.keycode, key.duration);
     CallbackAddKey(key);
   }
 }
@@ -1005,10 +1019,11 @@ void CCECClient::AddKey(const cec_keypress &key)
       key.keycode < CEC_USER_CONTROL_CODE_SELECT)
   {
     // send back the previous key if there is one
+    LIB_CEC->AddLog(CEC_LOG_DEBUG, "Unexpected key %s (%1x) D:%dms", ToString(key.keycode), key.keycode, key.duration);
     AddKey();
     return;
   }
-
+  bool isrepeat = false;
   cec_keypress transmitKey(key);
   cec_user_control_code comboKey(m_configuration.clientVersion >= CEC_CLIENT_VERSION_2_0_5 ?
       m_configuration.comboKey : CEC_USER_CONTROL_CODE_STOP);
@@ -1028,27 +1043,60 @@ void CCECClient::AddKey(const cec_keypress &key)
         transmitKey.keycode = CEC_USER_CONTROL_CODE_DOT;
       // default, send back the previous key
       else
+      {
+        LIB_CEC->AddLog(CEC_LOG_DEBUG, "Combo key %s (%1x) D%dms:", ToString(key.keycode), key.keycode, key.duration);
         AddKey(true);
+      }
     }

+    LIB_CEC->AddLog(CEC_LOG_DEBUG, "key pressed: %s (%1x) current(%lx) duration(%d)", ToString(transmitKey.keycode), transmitKey.keycode, m_iCurrentButton, key.duration);
+
     if (m_iCurrentButton == key.keycode)
     {
-      m_buttontime = GetTimeMs();
+      m_updateButtontime = GetTimeMs();
+      m_releaseButtontime = m_updateButtontime + (m_configuration.iButtonReleaseDelayMs ? m_configuration.iButtonReleaseDelayMs : CEC_BUTTON_TIMEOUT);
+      // want to have seen some updated before considering a repeat
+      if (m_configuration.iButtonRepeatRateMs)
+      {
+        if (!m_repeatButtontime && m_pressedButtoncount > 1)
+          m_repeatButtontime = m_initialButtontime + DoubleTapTimeoutMS();
+        isrepeat = true;
+      }
+      m_pressedButtoncount++;
     }
     else
     {
-      AddKey();
+      if (m_iCurrentButton != transmitKey.keycode)
+      {
+        LIB_CEC->AddLog(CEC_LOG_DEBUG, "Changed key %s (%1x) D:%dms cur:%lx", ToString(transmitKey.keycode), transmitKey.keycode, transmitKey.duration, m_iCurrentButton);
+        AddKey();
+      }
       if (key.duration == 0)
       {
         m_iCurrentButton = transmitKey.keycode;
-        m_buttontime = m_iCurrentButton == CEC_USER_CONTROL_CODE_UNKNOWN || key.duration > 0 ? 0 : GetTimeMs();
+        if (m_iCurrentButton == CEC_USER_CONTROL_CODE_UNKNOWN)
+        {
+          m_initialButtontime = 0;
+          m_updateButtontime = 0;
+          m_repeatButtontime = 0;
+          m_releaseButtontime = 0;
+          m_pressedButtoncount = 0;
+        }
+        else
+        {
+          m_initialButtontime = GetTimeMs();
+          m_updateButtontime = m_initialButtontime;
+          m_repeatButtontime = 0; // set this on next update
+          m_releaseButtontime = m_initialButtontime + (m_configuration.iButtonReleaseDelayMs ? m_configuration.iButtonReleaseDelayMs : CEC_BUTTON_TIMEOUT);
+          m_pressedButtoncount = 1;
+        }
       }
     }
   }

-  if (key.keycode != comboKey || key.duration > 0)
+  if (!isrepeat && (key.keycode != comboKey || key.duration > 0))
   {
-    LIB_CEC->AddLog(CEC_LOG_DEBUG, "key pressed: %s (%1x)", ToString(transmitKey.keycode), transmitKey.keycode);
+    LIB_CEC->AddLog(CEC_LOG_DEBUG, "key pressed: %s (%1x, %d)", ToString(transmitKey.keycode), transmitKey.keycode, transmitKey.duration);
     CallbackAddKey(transmitKey);
   }
 }
@@ -1060,6 +1108,7 @@ void CCECClient::SetCurrentButton(const cec_user_control_code iButtonCode)
   key.duration = 0;
   key.keycode = iButtonCode;

+  LIB_CEC->AddLog(CEC_LOG_DEBUG, "SetCurrentButton %s (%1x) D:%dms cur:%lx", ToString(key.keycode), key.keycode, key.duration);
   AddKey(key);
 }

@@ -1076,35 +1125,59 @@ uint16_t CCECClient::CheckKeypressTimeout(void)
   {
     CLockObject lock(m_mutex);
     uint64_t iNow = GetTimeMs();
+    LIB_CEC->AddLog(CEC_LOG_DEBUG, "%s T:%.3f", __FUNCTION__, iNow*1e-3);
     cec_user_control_code comboKey(m_configuration.clientVersion >= CEC_CLIENT_VERSION_2_0_5 ?
         m_configuration.comboKey : CEC_USER_CONTROL_CODE_STOP);
     uint32_t iTimeoutMs(m_configuration.clientVersion >= CEC_CLIENT_VERSION_2_0_5 ?
         m_configuration.iComboKeyTimeoutMs : CEC_DEFAULT_COMBO_TIMEOUT_MS);

-    if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN &&
-          ((m_iCurrentButton == comboKey && iTimeoutMs > 0 && iNow - m_buttontime > iTimeoutMs) ||
-          (m_iCurrentButton != comboKey && iNow - m_buttontime > CEC_BUTTON_TIMEOUT)))
+    if (m_iCurrentButton == comboKey && iTimeoutMs > 0 && iNow - m_updateButtontime >= iTimeoutMs)
     {
-      key.duration = (unsigned int) (iNow - m_buttontime);
+      key.duration = (unsigned int) (iNow - m_initialButtontime);
       key.keycode = m_iCurrentButton;

       m_iCurrentButton = CEC_USER_CONTROL_CODE_UNKNOWN;
-      m_buttontime = 0;
+      m_initialButtontime = 0;
+      m_updateButtontime = 0;
+      m_repeatButtontime = 0;
+      m_releaseButtontime = 0;
+      m_pressedButtoncount = 0;
+    }
+    else if (m_iCurrentButton != comboKey && m_releaseButtontime && iNow >= (uint64_t)m_releaseButtontime)
+    {
+      key.duration = (unsigned int) (iNow - m_initialButtontime);
+      key.keycode = CEC_USER_CONTROL_CODE_UNKNOWN;
+
+      m_iCurrentButton = CEC_USER_CONTROL_CODE_UNKNOWN;
+      m_initialButtontime = 0;
+      m_updateButtontime = 0;
+      m_repeatButtontime = 0;
+      m_releaseButtontime = 0;
+      m_pressedButtoncount = 0;
+    }
+    else if (m_iCurrentButton != comboKey && m_repeatButtontime && iNow >= (uint64_t)m_repeatButtontime)
+    {
+      key.duration = (unsigned int) (iNow - m_initialButtontime);
+      key.keycode = m_iCurrentButton;
+      m_repeatButtontime = iNow + m_configuration.iButtonRepeatRateMs;
+      timeout = std::min((uint64_t)timeout, m_repeatButtontime - iNow);
     }
     else
     {
-      // time when this keypress will be released and we'd like to be called again
-      unsigned int timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
-      if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN && m_iCurrentButton == comboKey && iTimeoutMs > 0)
-        timeout = iTimeoutMs - (iNow - m_buttontime) + 1;
-      else if (m_iCurrentButton != CEC_USER_CONTROL_CODE_UNKNOWN && m_iCurrentButton != comboKey)
-        timeout = CEC_BUTTON_TIMEOUT - (iNow - m_buttontime) + 1;
+      if (m_iCurrentButton == comboKey && iTimeoutMs > 0)
+        timeout = std::min((uint64_t)timeout, m_updateButtontime - iNow + iTimeoutMs);
+      if (m_iCurrentButton != comboKey && m_releaseButtontime)
+        timeout = std::min((uint64_t)timeout, m_releaseButtontime - iNow);
+      if (m_iCurrentButton != comboKey && m_repeatButtontime)
+        timeout = std::min((uint64_t)timeout, m_repeatButtontime - iNow);
       if (timeout > CEC_PROCESSOR_SIGNAL_WAIT_TIME)
       {
-        LIB_CEC->AddLog(CEC_LOG_ERROR, "Unexpected timeout: %d (%.3f %.3f %.3f) k:%02x", timeout, iNow*1e-3, m_buttontime*1e-3, CEC_BUTTON_TIMEOUT*1e-3, m_iCurrentButton);
+        LIB_CEC->AddLog(CEC_LOG_ERROR, "Unexpected timeout: %d (%.3f %.3f %.3f) k:%02x", timeout, iNow*1e-3, m_updateButtontime*1e-3, m_releaseButtontime*1e-3, m_iCurrentButton);
         timeout = CEC_PROCESSOR_SIGNAL_WAIT_TIME;
       }
     }
+    LIB_CEC->AddLog(CEC_LOG_DEBUG, "Key %s: %s (duration:%d) (%1x) timeout:%dms (rel:%d,rep:%d,prs:%d)", ToString(m_iCurrentButton), key.keycode == CEC_USER_CONTROL_CODE_UNKNOWN ? "idle" : m_repeatButtontime ? "repeated" : "released", key.duration,
+        m_iCurrentButton, timeout, (int)(m_releaseButtontime ? m_releaseButtontime - iNow : 0), (int)(m_repeatButtontime ? m_repeatButtontime - iNow : 0), m_pressedButtoncount);
   }

   if (key.keycode != CEC_USER_CONTROL_CODE_UNKNOWN)
diff --git a/src/lib/CECClient.h b/src/lib/CECClient.h
index 84fb909..27af3f9 100644
--- a/src/lib/CECClient.h
+++ b/src/lib/CECClient.h
@@ -311,7 +311,11 @@ namespace CEC
     PLATFORM::CMutex      m_mutex;                             /**< mutex for changes to this instance */
     PLATFORM::CMutex      m_cbMutex;                           /**< mutex that is held when doing anything with callbacks */
     cec_user_control_code m_iCurrentButton;                    /**< the control code of the button that's currently held down (if any) */
-    int64_t               m_buttontime;                        /**< the timestamp when the button was pressed (in seconds since epoch), or 0 if none was pressed. */
+    int64_t               m_initialButtontime;                 /**< the timestamp when the button was initially pressed (in seconds since epoch), or 0 if none was pressed. */
+    int64_t               m_updateButtontime;                  /**< the timestamp when the button was updated (in seconds since epoch), or 0 if none was pressed. */
+    int64_t               m_repeatButtontime;                  /**< the timestamp when the button will next repeat (in seconds since epoch), or 0 if repeat is disabled. */
+    int64_t               m_releaseButtontime;                 /**< the timestamp when the button will be released (in seconds since epoch), or 0 if none was pressed. */
+    int32_t               m_pressedButtoncount;                /**< the number of times a button released message has been seen for this press. */
     int64_t               m_iPreventForwardingPowerOffCommand; /**< prevent forwarding standby commands until this time */
     int64_t               m_iLastKeypressTime;                 /**< last time a key press was sent to the client */
     cec_keypress          m_lastKeypress;                      /**< the last key press that was sent to the client */
--
1.9.1


From 23860987ec534a4aecf93100bef3736c2620fb93 Mon Sep 17 00:00:00 2001
From: popcornmix <popcornmix@gmail.com>
Date: Tue, 28 Oct 2014 01:21:35 +0000
Subject: [PATCH 5/5] Skip double press removal. It is handled through other
 means.

---
 src/lib/CECClient.cpp | 18 +-----------------
 src/lib/CECClient.h   |  2 --
 2 files changed, 1 insertion(+), 19 deletions(-)

diff --git a/src/lib/CECClient.cpp b/src/lib/CECClient.cpp
index 68eaee9..9b4b533 100644
--- a/src/lib/CECClient.cpp
+++ b/src/lib/CECClient.cpp
@@ -57,11 +57,8 @@ CCECClient::CCECClient(CCECProcessor *processor, const libcec_configuration &con
     m_repeatButtontime(0),
     m_releaseButtontime(0),
     m_pressedButtoncount(0),
-    m_iPreventForwardingPowerOffCommand(0),
-    m_iLastKeypressTime(0)
+    m_iPreventForwardingPowerOffCommand(0)
 {
-  m_lastKeypress.keycode = CEC_USER_CONTROL_CODE_UNKNOWN;
-  m_lastKeypress.duration = 0;
   m_configuration.Clear();
   // set the initial configuration
   SetConfiguration(configuration);
@@ -1568,20 +1565,7 @@ void CCECClient::CallbackAddKey(const cec_keypress &key)
 {
   CLockObject lock(m_cbMutex);
   if (m_configuration.callbacks && m_configuration.callbacks->CBCecKeyPress)
-  {
-    // prevent double taps
-    int64_t now = GetTimeMs();
-    if (m_lastKeypress.keycode != key.keycode ||
-        key.duration > 0 ||
-        now - m_iLastKeypressTime >= DoubleTapTimeoutMS())
-    {
-      // no double tap
-      if (key.duration == 0)
-        m_iLastKeypressTime = now;
-      m_lastKeypress = key;
       m_configuration.callbacks->CBCecKeyPress(m_configuration.callbackParam, key);
-    }
-  }
 }

 void CCECClient::CallbackAddLog(const cec_log_message &message)
diff --git a/src/lib/CECClient.h b/src/lib/CECClient.h
index 27af3f9..eb11d9b 100644
--- a/src/lib/CECClient.h
+++ b/src/lib/CECClient.h
@@ -317,7 +317,5 @@ namespace CEC
     int64_t               m_releaseButtontime;                 /**< the timestamp when the button will be released (in seconds since epoch), or 0 if none was pressed. */
     int32_t               m_pressedButtoncount;                /**< the number of times a button released message has been seen for this press. */
     int64_t               m_iPreventForwardingPowerOffCommand; /**< prevent forwarding standby commands until this time */
-    int64_t               m_iLastKeypressTime;                 /**< last time a key press was sent to the client */
-    cec_keypress          m_lastKeypress;                      /**< the last key press that was sent to the client */
   };
 }
--
1.9.1
